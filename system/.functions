#!/usr/bin/env bash

# Kill process by port
function killport()
{
    lsof -i tcp:$1 | awk 'FNR == 2 {print $2}' | xargs kill -9
}

# Toggle "focus mode"
function focus() {
    osascript -e 'tell application "System Events" to keystroke "d" using {command down, option down}'
    osascript -e 'tell application "System Events" to keystroke "d" using {command down, option down, control down}'
}

# Simple calculator
function calc() {
    local result="";
    result="$(printf "scale=10;$*\n" | bc --mathlib | tr -d '\\\n')";
    #                       └─ default (when `--mathlib` is used) is 20
    #
    if [[ "$result" == *.* ]]; then
        # improve the output for decimal numbers
        printf "$result" |
        sed -e 's/^\./0./'        `# add "0" for cases like ".5"` \
            -e 's/^-\./-0./'      `# add "0" for cases like "-.5"`\
            -e 's/0*$//;s/\.$//';  # remove trailing zeros
    else
        printf "$result";
    fi;
    printf "\n";
}

# Create a new directory and enter it
function mkd() {
    mkdir -p "$@" && cd "$_";
}

# Change working directory to the top-most Finder window location
function cdf() { # short for `cdfinder`
    cd "$(osascript -e 'tell app "Finder" to POSIX path of (insertion location as alias)')";
}

# Reload dotfiles
function reload-dotfiles() {
    if [ -d "$HOME/dotfiles" ]; then
        (cd "$HOME/dotfiles" && git pull origin master && ./bootstrap.sh)
        source "$HOME/.zshrc"
    fi
}

# Create a .tar.gz archive, using `zopfli`, `pigz` or `gzip` for compression
function targz() {
    local tmpFile="${@%/}.tar";
    tar -cvf "${tmpFile}" --exclude=".DS_Store" "${@}" || return 1;

    size=$(
        stat -f"%z" "${tmpFile}" 2> /dev/null; # macOS `stat`
        stat -c"%s" "${tmpFile}" 2> /dev/null;  # GNU `stat`
    );

    local cmd="";
    if (( size < 52428800 )) && hash zopfli 2> /dev/null; then
        # the .tar file is smaller than 50 MB and Zopfli is available; use it
        cmd="zopfli";
    else
        if hash pigz 2> /dev/null; then
            cmd="pigz";
        else
            cmd="gzip";
        fi;
    fi;

    echo "Compressing .tar ($((size / 1000)) kB) using \`${cmd}\`…";
    "${cmd}" -v "${tmpFile}" || return 1;
    [ -f "${tmpFile}" ] && rm "${tmpFile}";

    zippedSize=$(
        stat -f"%z" "${tmpFile}.gz" 2> /dev/null; # macOS `stat`
        stat -c"%s" "${tmpFile}.gz" 2> /dev/null; # GNU `stat`
    );

    echo "${tmpFile}.gz ($((zippedSize / 1000)) kB) created successfully.";
}

# Determine size of a file or total size of a directory
function fs() {
    if du -b /dev/null > /dev/null 2>&1; then
        local arg=-sbh;
    else
        local arg=-sh;
    fi
    if [[ -n "$@" ]]; then
        du $arg -- "$@";
    else
        du $arg .[^.]* ./*;
    fi;
}

# Use Git’s colored diff when available
hash git &>/dev/null;
if [ $? -eq 0 ]; then
    function diff() {
        git diff --no-index --color-words "$@";
    }
fi;

# Create a data URL from a file
function dataurl() {
    local mimeType=$(file -b --mime-type "$1");
    if [[ $mimeType == text/* ]]; then
        mimeType="${mimeType};charset=utf-8";
    fi
    echo "data:${mimeType};base64,$(openssl base64 -in "$1" | tr -d '\n')";
}

# Start an HTTP server from a directory, optionally specifying the port
function server() {
    local port="${1:-8000}";
    sleep 1 && open "http://localhost:${port}/" &
    python -m http.server $port
}

# Compare original and gzipped file size
function gz() {
    local origsize=$(wc -c < "$1");
    local gzipsize=$(gzip -c "$1" | wc -c);
    local ratio=$(echo "$gzipsize * 100 / $origsize" | bc -l);
    printf "orig: %d bytes\n" "$origsize";
    printf "gzip: %d bytes (%2.2f%%)\n" "$gzipsize" "$ratio";
}

# Show all the names (CNs and SANs) listed in the SSL certificate
# for a given domain
function getcertnames() {
    if [ -z "${1}" ]; then
        echo "ERROR: No domain specified.";
        return 1;
    fi;

    local domain="${1}";
    echo "Testing ${domain}…";
    echo ""; # newline

    local tmp=$(echo -e "GET / HTTP/1.0\nEOT" \
        | openssl s_client -connect "${domain}:443" -servername "${domain}" 2>&1);

    if [[ "${tmp}" = *"-----BEGIN CERTIFICATE-----"* ]]; then
        local certText=$(echo "${tmp}" \
            | openssl x509 -text -certopt "no_aux, no_header, no_issuer, no_pubkey, \
            no_serial, no_sigdump, no_signame, no_validity, no_version");
        echo "Common Name:";
        echo ""; # newline
        echo "${certText}" | grep "Subject:" | sed -e "s/^.*CN=//" | sed -e "s/\/emailAddress=.*//";
        echo ""; # newline
        echo "Subject Alternative Name(s):";
        echo ""; # newline
        echo "${certText}" | grep -A 1 "Subject Alternative Name:" \
            | sed -e "2s/DNS://g" -e "s/ //g" | tr "," "\n" | tail -n +2;
        return 0;
    else
        echo "ERROR: Certificate not found.";
        return 1;
    fi;
}

# `tre` is a shorthand for `tree` with hidden files and color enabled, ignoring
# the `.git` directory, listing directories first. The output gets piped into
# `less` with options to preserve color and line numbers, unless the output is
# small enough for one screen.
function tre() {
    tree -aC -I '.git|node_modules|bower_components' --dirsfirst "$@" | less -FRNX;
}

# Spin up a mock HTTP server, listening to the given port, that echos back any POSTed data
function mhttp() {
    while true; do echo "Hello, World!" | nc -l $1; done
}

# POWER

# Find CF request details by ray id
function cflogs() {
    curl -H "Authorization: Bearer ${CLOUDFLARE_TOKEN}" https://api.cloudflare.com/client/v4/zones/e8900cc9c0e8dc2ade675327b3f634fa/logs/rayids/$1
}

# FZF WORKFLOWS

# Fuzzy-find file and open in Zed
function ff() {
    local file
    file=$(find . -type f \
        -not -path '*/.git/*' \
        -not -path '*/node_modules/*' \
        -not -path '*/.mise/*' \
        2>/dev/null | fzf --height=50% --layout=reverse --border --preview 'bat --style=numbers --color=always --line-range=:200 {}' --preview-window=right:60%) || return 1

    if command -v zed >/dev/null; then
        zed "$file"
    elif command -v code >/dev/null; then
        code "$file"
    else
        ${EDITOR:-vim} "$file"
    fi
}

# Fuzzy-find directory and cd into it
function fcd() {
    local dir
    dir=$(find . -type d \
        -not -path '*/.git/*' \
        -not -path '*/node_modules/*' \
        -not -path '*/.mise/*' \
        2>/dev/null | fzf --height=50% --layout=reverse --border) || return 1
    cd "$dir" || return 1
}

# Fuzzy-switch git branch
function fbr() {
    local branch
    branch=$(git for-each-ref --sort=-committerdate refs/heads refs/remotes --format='%(refname:short)' \
        | grep -v '^origin/HEAD$' \
        | fzf --height=50% --layout=reverse --border --preview 'git log --oneline --decorate -n 20 {}') || return 1

    # If selecting a remote branch, create/tracking checkout
    if [[ "$branch" == origin/* ]]; then
        git checkout --track "$branch"
    else
        git checkout "$branch"
    fi
}

# Fuzzy-search ripgrep results and open selected file:line
function frg() {
    local query selected file line
    query="${1:-}"
    selected=$(rg --line-number --no-heading --color=always --smart-case "$query" . \
        | fzf --ansi --height=60% --layout=reverse --border \
              --delimiter ':' \
              --preview 'bat --style=numbers --color=always {1} --highlight-line {2}' \
              --preview-window=right:60%) || return 1

    file=$(echo "$selected" | awk -F: '{print $1}')
    line=$(echo "$selected" | awk -F: '{print $2}')

    if command -v zed >/dev/null; then
        zed "$file:$line"
    elif command -v code >/dev/null; then
        code -g "$file:$line"
    else
        ${EDITOR:-vim} "+$line" "$file"
    fi
}

# Fuzzy pick process and kill it
function fkill() {
    local pid
    pid=$(ps -ef | sed 1d | fzf --height=50% --layout=reverse --border --preview 'echo {}' | awk '{print $2}') || return 1
    kill -9 "$pid"
}

